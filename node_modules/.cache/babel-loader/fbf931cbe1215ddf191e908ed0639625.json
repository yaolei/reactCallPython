{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\n\nconst events_1 = require(\"events\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst os_1 = require(\"os\");\n\nconst path_1 = require(\"path\");\n\nconst stream_1 = require(\"stream\");\n\nconst fs_1 = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */\n\n\nfunction extend(obj, ...args) {\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (let key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */\n\n\nfunction getRandomInt() {\n  return Math.floor(Math.random() * 10000000000);\n}\n\nconst execPromise = util_1.promisify(child_process_1.exec);\n\nclass PythonShellError extends Error {}\n\nexports.PythonShellError = PythonShellError;\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\n\nclass NewlineTransformer extends stream_1.Transform {\n  _transform(chunk, encoding, callback) {\n    let data = chunk.toString();\n    if (this._lastLineData) data = this._lastLineData + data;\n    const lines = data.split(os_1.EOL);\n    this._lastLineData = lines.pop(); //@ts-ignore this works, node ignores the encoding if it's a number\n\n    lines.forEach(this.push.bind(this));\n    callback();\n  }\n\n  _flush(done) {\n    if (this._lastLineData) this.push(this._lastLineData);\n    this._lastLineData = null;\n    done();\n  }\n\n}\n\nexports.NewlineTransformer = NewlineTransformer;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\n\nclass PythonShell extends events_1.EventEmitter {\n  /**\r\n   * spawns a python process\r\n   * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n   * @param options\r\n   * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n   * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n   */\n  constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\n    super();\n    /**\r\n     * returns either pythonshell func (if val string) or custom func (if val Function)\r\n     */\n\n    function resolve(type, val) {\n      if (typeof val === 'string') {\n        // use a built-in function using its name\n        return PythonShell[type][val];\n      } else if (typeof val === 'function') {\n        // use a custom function\n        return val;\n      }\n    }\n\n    if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n    let self = this;\n    let errorData = '';\n    events_1.EventEmitter.call(this);\n    options = extend({}, PythonShell.defaultOptions, options);\n    let pythonPath;\n\n    if (!options.pythonPath) {\n      pythonPath = PythonShell.defaultPythonPath;\n    } else pythonPath = options.pythonPath;\n\n    let pythonOptions = toArray(options.pythonOptions);\n    let scriptArgs = toArray(options.args);\n    this.scriptPath = path_1.join(options.scriptPath || '', scriptPath);\n    this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\n    this.mode = options.mode || 'text';\n    this.formatter = resolve('format', options.formatter || this.mode);\n    this.parser = resolve('parse', options.parser || this.mode); // We don't expect users to ever format stderr as JSON so we default to text mode\n\n    this.stderrParser = resolve('parse', options.stderrParser || 'text');\n    this.terminated = false;\n    this.childProcess = child_process_1.spawn(pythonPath, this.command, options);\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n      self[name] = self.childProcess[name];\n      self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\n    }); // Node buffers stdout&stderr in batches regardless of newline placement\n    // This is troublesome if you want to recieve distinct individual messages\n    // for example JSON parsing breaks if it recieves partial JSON\n    // so we use newlineTransformer to emit each batch seperated by newline\n\n    if (this.parser && this.stdout) {\n      if (!stdoutSplitter) stdoutSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stdoutSplitter.setEncoding(options.encoding || 'utf8');\n      this.stdout.pipe(stdoutSplitter).on('data', chunk => {\n        this.emit('message', self.parser(chunk));\n      });\n    } // listen to stderr and emit errors for incoming data\n\n\n    if (this.stderrParser && this.stderr) {\n      if (!stderrSplitter) stderrSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stderrSplitter.setEncoding(options.encoding || 'utf8');\n      this.stderr.pipe(stderrSplitter).on('data', chunk => {\n        this.emit('stderr', self.stderrParser(chunk));\n      });\n    }\n\n    if (this.stderr) {\n      this.stderr.on('data', function (data) {\n        errorData += '' + data;\n      });\n      this.stderr.on('end', function () {\n        self.stderrHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stderrHasEnded = true;\n    }\n\n    if (this.stdout) {\n      this.stdout.on('end', function () {\n        self.stdoutHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stdoutHasEnded = true;\n    }\n\n    this.childProcess.on('error', function (err) {\n      self.emit('error', err);\n    });\n    this.childProcess.on('exit', function (code, signal) {\n      self.exitCode = code;\n      self.exitSignal = signal;\n      terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n      if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n      let err;\n\n      if (self.exitCode && self.exitCode !== 0) {\n        if (errorData) {\n          err = self.parseError(errorData);\n        } else {\n          err = new PythonShellError('process exited with code ' + self.exitCode);\n        }\n\n        err = extend(err, {\n          executable: pythonPath,\n          options: pythonOptions.length ? pythonOptions : null,\n          script: self.scriptPath,\n          args: scriptArgs.length ? scriptArgs : null,\n          exitCode: self.exitCode\n        }); // do not emit error if only a callback is used\n\n        if (self.listeners('pythonError').length || !self._endCallback) {\n          self.emit('pythonError', err);\n        }\n      }\n\n      self.terminated = true;\n      self.emit('close');\n      self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n    }\n\n    ;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @returns rejects promise w/ string error output if syntax failure\r\n   */\n\n\n  static checkSyntax(code) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const randomInt = getRandomInt();\n      const filePath = os_1.tmpdir() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\n      const writeFilePromise = util_1.promisify(fs_1.writeFile);\n      return writeFilePromise(filePath, code).then(() => {\n        return this.checkSyntaxFile(filePath);\n      });\n    });\n  }\n\n  static getPythonPath() {\n    return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @returns {Promise} rejects w/ stderr if syntax failure\r\n   */\n\n\n  static checkSyntaxFile(filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pythonPath = this.getPythonPath();\n      let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\n      return execPromise(compileCommand);\n    });\n  }\n  /**\r\n   * Runs a Python script and returns collected messages\r\n   * @param  {string}   scriptPath   The path to the script to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n\n\n  static run(scriptPath, options, callback) {\n    let pyshell = new PythonShell(scriptPath, options);\n    let output = [];\n    return pyshell.on('message', function (message) {\n      output.push(message);\n    }).end(function (err) {\n      return callback(err ? err : null, output.length ? output : null);\n    });\n  }\n\n  /**\r\n   * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n   * @param  {string}   code   The python code to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n  static runString(code, options, callback) {\n    // put code in temp file\n    const randomInt = getRandomInt();\n    const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\n    fs_1.writeFileSync(filePath, code);\n    return PythonShell.run(filePath, options, callback);\n  }\n\n  static getVersion(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    return execPromise(pythonPath + \" --version\");\n  }\n\n  static getVersionSync(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    return child_process_1.execSync(pythonPath + \" --version\").toString();\n  }\n  /**\r\n   * Parses an error thrown from the Python process through stderr\r\n   * @param  {string|Buffer} data The stderr contents to parse\r\n   * @return {Error} The parsed error with extended stack trace when traceback is available\r\n   */\n\n\n  parseError(data) {\n    let text = '' + data;\n    let error;\n\n    if (/^Traceback/.test(text)) {\n      // traceback data is available\n      let lines = text.trim().split(os_1.EOL);\n      let exception = lines.pop();\n      error = new PythonShellError(exception);\n      error.traceback = data; // extend stack trace\n\n      error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\n      error.stack += lines.slice(1).join(os_1.EOL + '  ');\n    } else {\n      // otherwise, create a simpler error with stderr contents\n      error = new PythonShellError(text);\n    }\n\n    return error;\n  }\n\n  /**\r\n   * Sends a message to the Python shell through stdin\r\n   * Override this method to format data to be sent to the Python process\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  send(message) {\n    if (!this.stdin) throw new Error(\"stdin not open for writing\");\n    let data = this.formatter ? this.formatter(message) : message;\n    if (this.mode !== 'binary') data += os_1.EOL;\n    this.stdin.write(data);\n    return this;\n  }\n\n  /**\r\n   * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n   * this should cause the process to finish its work and close.\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  end(callback) {\n    if (this.childProcess.stdin) {\n      this.childProcess.stdin.end();\n    }\n\n    this._endCallback = callback;\n    return this;\n  }\n\n  /**\r\n   * Sends a kill signal to the process\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  kill(signal) {\n    this.childProcess.kill(signal);\n    this.terminated = true;\n    return this;\n  }\n\n  /**\r\n   * Alias for kill.\r\n   * @deprecated\r\n   */\n  terminate(signal) {\n    // todo: remove this next breaking release\n    return this.kill(signal);\n  }\n\n}\n\nexports.PythonShell = PythonShell; // starting 2020 python2 is deprecated so we choose 3 as default\n\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; //built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\n;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\r\nconst events_1 = require(\"events\");\r\nconst child_process_1 = require(\"child_process\");\r\nconst os_1 = require(\"os\");\r\nconst path_1 = require(\"path\");\r\nconst stream_1 = require(\"stream\");\r\nconst fs_1 = require(\"fs\");\r\nconst util_1 = require(\"util\");\r\nfunction toArray(source) {\r\n    if (typeof source === 'undefined' || source === null) {\r\n        return [];\r\n    }\r\n    else if (!Array.isArray(source)) {\r\n        return [source];\r\n    }\r\n    return source;\r\n}\r\n/**\r\n * adds arguments as properties to obj\r\n */\r\nfunction extend(obj, ...args) {\r\n    Array.prototype.slice.call(arguments, 1).forEach(function (source) {\r\n        if (source) {\r\n            for (let key in source) {\r\n                obj[key] = source[key];\r\n            }\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * gets a random int from 0-10000000000\r\n */\r\nfunction getRandomInt() {\r\n    return Math.floor(Math.random() * 10000000000);\r\n}\r\nconst execPromise = util_1.promisify(child_process_1.exec);\r\nclass PythonShellError extends Error {\r\n}\r\nexports.PythonShellError = PythonShellError;\r\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\r\nclass NewlineTransformer extends stream_1.Transform {\r\n    _transform(chunk, encoding, callback) {\r\n        let data = chunk.toString();\r\n        if (this._lastLineData)\r\n            data = this._lastLineData + data;\r\n        const lines = data.split(os_1.EOL);\r\n        this._lastLineData = lines.pop();\r\n        //@ts-ignore this works, node ignores the encoding if it's a number\r\n        lines.forEach(this.push.bind(this));\r\n        callback();\r\n    }\r\n    _flush(done) {\r\n        if (this._lastLineData)\r\n            this.push(this._lastLineData);\r\n        this._lastLineData = null;\r\n        done();\r\n    }\r\n}\r\nexports.NewlineTransformer = NewlineTransformer;\r\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\r\nclass PythonShell extends events_1.EventEmitter {\r\n    /**\r\n     * spawns a python process\r\n     * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n     * @param options\r\n     * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n     * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n     */\r\n    constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\r\n        super();\r\n        /**\r\n         * returns either pythonshell func (if val string) or custom func (if val Function)\r\n         */\r\n        function resolve(type, val) {\r\n            if (typeof val === 'string') {\r\n                // use a built-in function using its name\r\n                return PythonShell[type][val];\r\n            }\r\n            else if (typeof val === 'function') {\r\n                // use a custom function\r\n                return val;\r\n            }\r\n        }\r\n        if (scriptPath.trim().length == 0)\r\n            throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\r\n        let self = this;\r\n        let errorData = '';\r\n        events_1.EventEmitter.call(this);\r\n        options = extend({}, PythonShell.defaultOptions, options);\r\n        let pythonPath;\r\n        if (!options.pythonPath) {\r\n            pythonPath = PythonShell.defaultPythonPath;\r\n        }\r\n        else\r\n            pythonPath = options.pythonPath;\r\n        let pythonOptions = toArray(options.pythonOptions);\r\n        let scriptArgs = toArray(options.args);\r\n        this.scriptPath = path_1.join(options.scriptPath || '', scriptPath);\r\n        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\r\n        this.mode = options.mode || 'text';\r\n        this.formatter = resolve('format', options.formatter || this.mode);\r\n        this.parser = resolve('parse', options.parser || this.mode);\r\n        // We don't expect users to ever format stderr as JSON so we default to text mode\r\n        this.stderrParser = resolve('parse', options.stderrParser || 'text');\r\n        this.terminated = false;\r\n        this.childProcess = child_process_1.spawn(pythonPath, this.command, options);\r\n        ['stdout', 'stdin', 'stderr'].forEach(function (name) {\r\n            self[name] = self.childProcess[name];\r\n            self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\r\n        });\r\n        // Node buffers stdout&stderr in batches regardless of newline placement\r\n        // This is troublesome if you want to recieve distinct individual messages\r\n        // for example JSON parsing breaks if it recieves partial JSON\r\n        // so we use newlineTransformer to emit each batch seperated by newline\r\n        if (this.parser && this.stdout) {\r\n            if (!stdoutSplitter)\r\n                stdoutSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stdoutSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stdout.pipe(stdoutSplitter).on('data', (chunk) => {\r\n                this.emit('message', self.parser(chunk));\r\n            });\r\n        }\r\n        // listen to stderr and emit errors for incoming data\r\n        if (this.stderrParser && this.stderr) {\r\n            if (!stderrSplitter)\r\n                stderrSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stderrSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stderr.pipe(stderrSplitter).on('data', (chunk) => {\r\n                this.emit('stderr', self.stderrParser(chunk));\r\n            });\r\n        }\r\n        if (this.stderr) {\r\n            this.stderr.on('data', function (data) {\r\n                errorData += '' + data;\r\n            });\r\n            this.stderr.on('end', function () {\r\n                self.stderrHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stderrHasEnded = true;\r\n        }\r\n        if (this.stdout) {\r\n            this.stdout.on('end', function () {\r\n                self.stdoutHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stdoutHasEnded = true;\r\n        }\r\n        this.childProcess.on('error', function (err) {\r\n            self.emit('error', err);\r\n        });\r\n        this.childProcess.on('exit', function (code, signal) {\r\n            self.exitCode = code;\r\n            self.exitSignal = signal;\r\n            terminateIfNeeded();\r\n        });\r\n        function terminateIfNeeded() {\r\n            if (!self.stderrHasEnded || !self.stdoutHasEnded || (self.exitCode == null && self.exitSignal == null))\r\n                return;\r\n            let err;\r\n            if (self.exitCode && self.exitCode !== 0) {\r\n                if (errorData) {\r\n                    err = self.parseError(errorData);\r\n                }\r\n                else {\r\n                    err = new PythonShellError('process exited with code ' + self.exitCode);\r\n                }\r\n                err = extend(err, {\r\n                    executable: pythonPath,\r\n                    options: pythonOptions.length ? pythonOptions : null,\r\n                    script: self.scriptPath,\r\n                    args: scriptArgs.length ? scriptArgs : null,\r\n                    exitCode: self.exitCode\r\n                });\r\n                // do not emit error if only a callback is used\r\n                if (self.listeners('pythonError').length || !self._endCallback) {\r\n                    self.emit('pythonError', err);\r\n                }\r\n            }\r\n            self.terminated = true;\r\n            self.emit('close');\r\n            self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\r\n        }\r\n        ;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns rejects promise w/ string error output if syntax failure\r\n     */\r\n    static checkSyntax(code) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const randomInt = getRandomInt();\r\n            const filePath = os_1.tmpdir() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\r\n            const writeFilePromise = util_1.promisify(fs_1.writeFile);\r\n            return writeFilePromise(filePath, code).then(() => {\r\n                return this.checkSyntaxFile(filePath);\r\n            });\r\n        });\r\n    }\r\n    static getPythonPath() {\r\n        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\r\n    static checkSyntaxFile(filePath) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const pythonPath = this.getPythonPath();\r\n            let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\r\n            return execPromise(compileCommand);\r\n        });\r\n    }\r\n    /**\r\n     * Runs a Python script and returns collected messages\r\n     * @param  {string}   scriptPath   The path to the script to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static run(scriptPath, options, callback) {\r\n        let pyshell = new PythonShell(scriptPath, options);\r\n        let output = [];\r\n        return pyshell.on('message', function (message) {\r\n            output.push(message);\r\n        }).end(function (err) {\r\n            return callback(err ? err : null, output.length ? output : null);\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param  {string}   code   The python code to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static runString(code, options, callback) {\r\n        // put code in temp file\r\n        const randomInt = getRandomInt();\r\n        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\r\n        fs_1.writeFileSync(filePath, code);\r\n        return PythonShell.run(filePath, options, callback);\r\n    }\r\n    ;\r\n    static getVersion(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return execPromise(pythonPath + \" --version\");\r\n    }\r\n    static getVersionSync(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return child_process_1.execSync(pythonPath + \" --version\").toString();\r\n    }\r\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\r\n    parseError(data) {\r\n        let text = '' + data;\r\n        let error;\r\n        if (/^Traceback/.test(text)) {\r\n            // traceback data is available\r\n            let lines = text.trim().split(os_1.EOL);\r\n            let exception = lines.pop();\r\n            error = new PythonShellError(exception);\r\n            error.traceback = data;\r\n            // extend stack trace\r\n            error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\r\n            error.stack += lines.slice(1).join(os_1.EOL + '  ');\r\n        }\r\n        else {\r\n            // otherwise, create a simpler error with stderr contents\r\n            error = new PythonShellError(text);\r\n        }\r\n        return error;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    send(message) {\r\n        if (!this.stdin)\r\n            throw new Error(\"stdin not open for writing\");\r\n        let data = this.formatter ? this.formatter(message) : message;\r\n        if (this.mode !== 'binary')\r\n            data += os_1.EOL;\r\n        this.stdin.write(data);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    end(callback) {\r\n        if (this.childProcess.stdin) {\r\n            this.childProcess.stdin.end();\r\n        }\r\n        this._endCallback = callback;\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    kill(signal) {\r\n        this.childProcess.kill(signal);\r\n        this.terminated = true;\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */\r\n    terminate(signal) {\r\n        // todo: remove this next breaking release\r\n        return this.kill(signal);\r\n    }\r\n}\r\nexports.PythonShell = PythonShell;\r\n// starting 2020 python2 is deprecated so we choose 3 as default\r\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\r\nPythonShell.defaultOptions = {}; //allow global overrides for options\r\n// built-in formatters\r\nPythonShell.format = {\r\n    text: function toText(data) {\r\n        if (!data)\r\n            return '';\r\n        else if (typeof data !== 'string')\r\n            return data.toString();\r\n        return data;\r\n    },\r\n    json: function toJson(data) {\r\n        return JSON.stringify(data);\r\n    }\r\n};\r\n//built-in parsers\r\nPythonShell.parse = {\r\n    text: function asText(data) {\r\n        return data;\r\n    },\r\n    json: function asJson(data) {\r\n        return JSON.parse(data);\r\n    }\r\n};\r\n;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}